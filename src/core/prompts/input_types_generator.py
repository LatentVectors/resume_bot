"""Generator for TypedDict classes from prompt templates."""

from __future__ import annotations

from pathlib import Path

from src.logging_config import logger

from .constants import PROMPTS_DIR
from .loader import load_prompt
from .names import PromptName


def generate_prompt_input_types() -> int:
    """Generate TypedDict classes for all prompt templates.

    Scans the prompts directory, loads each prompt template, extracts input variables,
    and generates TypedDict classes with a type-safe get_prompt() function.

    Returns:
        Number of TypedDict classes generated
    """
    # Scan prompts directory
    prompt_files = sorted(PROMPTS_DIR.glob("*.json"))

    if not prompt_files:
        logger.warning("No prompt files found in %s", PROMPTS_DIR)
        return 0

    # Collect data for each prompt template
    prompt_data: list[dict] = []
    has_message_placeholders = False

    for prompt_file in prompt_files:
        prompt_name_str = prompt_file.stem
        try:
            # Get the corresponding enum member
            prompt_name = PromptName(prompt_name_str)

            # Load the prompt template
            prompt = load_prompt(prompt_name)

            # Get input variables
            input_vars = getattr(prompt, "input_variables", [])

            # Detect MessagesPlaceholder variables
            message_placeholder_vars = set()
            if hasattr(prompt, "messages"):
                for msg in prompt.messages:
                    if type(msg).__name__ == "MessagesPlaceholder":
                        message_placeholder_vars.add(msg.variable_name)
                        has_message_placeholders = True

            # Generate TypedDict class name
            words = prompt_name_str.split("_")
            class_name = "".join(word.capitalize() for word in words) + "Input"

            prompt_data.append(
                {
                    "enum_name": prompt_name.name,
                    "enum_value": prompt_name.value,
                    "class_name": class_name,
                    "input_vars": input_vars,
                    "message_placeholder_vars": message_placeholder_vars,
                }
            )

        except Exception as exc:
            logger.error("Failed to process prompt %s: %s", prompt_name_str, exc, exception=True)
            continue

    if not prompt_data:
        logger.error("No prompt templates could be processed")
        return 0

    # Generate the file content
    content = _generate_input_types_file(prompt_data, has_message_placeholders)

    # Write to file
    output_file = Path("src/core/prompts/input_types.py")
    output_file.write_text(content, encoding="utf-8")

    logger.info("Generated %d input type classes", len(prompt_data))

    return len(prompt_data)


def _generate_input_types_file(prompt_data: list[dict], has_message_placeholders: bool) -> str:
    """Generate the complete input_types.py file content.

    Args:
        prompt_data: List of dicts with prompt metadata
        has_message_placeholders: Whether any prompt uses MessagesPlaceholder

    Returns:
        Complete file content as string
    """
    # Generate TypedDict classes
    typeddict_classes = []
    for data in prompt_data:
        class_name = data["class_name"]
        input_vars = data["input_vars"]
        message_placeholder_vars = data.get("message_placeholder_vars", set())

        if input_vars:
            # Generate fields with appropriate types
            fields = []
            for var in input_vars:
                if var in message_placeholder_vars:
                    fields.append(f"    {var}: Sequence[BaseMessage]")
                else:
                    fields.append(f"    {var}: str")
            fields_str = "\n".join(fields)

            typeddict_class = f'''class {class_name}(TypedDict):
    """Input variables for {data["enum_value"]} prompt template."""

{fields_str}
'''
        else:
            typeddict_class = f'''class {class_name}(TypedDict):
    """Input variables for {data["enum_value"]} prompt template."""

    pass  # No input variables for this prompt template
'''
        typeddict_classes.append(typeddict_class)

    typeddict_classes_str = "\n\n".join(typeddict_classes)

    # Generate imports based on whether message placeholders are used
    if has_message_placeholders:
        imports = """from __future__ import annotations

from collections.abc import Sequence
from typing import TypedDict

from langchain_core.messages import BaseMessage"""
    else:
        imports = """from __future__ import annotations

from typing import TypedDict"""

    # Assemble complete file
    content = f"""# AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
# Generated by: prompts sync
# To update: run `python cli.py prompts sync`

{imports}


{typeddict_classes_str}
"""

    return content
